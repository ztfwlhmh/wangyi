#牛牛以前在老师那里得到了一个正整数数对（x,y），牛牛忘记他们具体是多少了。但是牛牛记得老师告诉他x和y均不大于n,并且x除以y的余数大于等于k。牛牛希望你能帮他计算一共有多少个可能的数对。
#输入包括两个正整数n,k(1<=n<=10^5,0<=k<=n-1)
#对于每个测试用例，输出一个正整数表示可能的数对数量。

import java.util.Scanner;

public class wangyi02 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {
            int n = in.nextInt();
            int k = in.nextInt();
            if (k == 0)
                System.out.println(1L * n * n);
            else {
                long ans = 0L;
                for (int i = k + 1; i <= n; i++) {
                    ans += (n / i) * (i - k);
                    if (n % i >= k)
                        ans += n % i - k + 1;
                }
                System.out.println(ans);
            }
        }
    }
}

#为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你
#每个输入包含一个测试用例。 每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N<=100000)和小伙伴的数量M(M<=100000)。 接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di<=1000000000)和报酬Pi(Pi<=1000000000)。 接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai<=1000000000)。 保证不存在两项工作的报酬相同。
#对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。
#维护一个（N+M）的dp[N+M]的数组，记录不同能力和不同难度下的最大薪酬  复杂度 MAX（O(NlogN),O(MlogM),O(N+M))


#又到了丰收的季节，恰好小易去牛牛的果园里游玩。 牛牛常说他多整个果园的每个地方都了如指掌，小易不太相信，所以他想考考牛牛。 在果园里有N堆苹果，每堆苹果的数量为ai,小易希望知道从左往右数第x个苹果是属于哪一堆的。 牛牛觉得问题太简单了，所以希望你来替他回答。
#第一行一个数n(1<=n<=10^5) 第二行n个数ai(1<=ai<=1000),表示从左往右数第i堆有多少苹果 第三行一个数m(1<=m<=10^5),表示有m次询问 第四行m个数qi,表示小易希望知道第qi个苹果属于哪一堆。
#m行，第i行输出第qi个苹果属于哪一堆
